`sort =
    | /[0-9]+(\.[0-9]*)?/   // any digit
    | /\*/                  // literal *
    | /".*?"/               // string litteral
	| ident

	| ||patt . sort
    | ||patt .. sort
    | sort . sort
	| sort sort
	| ( paramatch )
    `paramatch =
        | > patt guard ; sort paramatch

	| ^^patt % sort
    | ^^patt %% sort
    | sort % sort
	| sort@sort

	| (with sort branch)
	| (iterate sort branch)

    `branch =
        | > patt guard ; sort branch
        | | sort

    `guard =
        | <empty>
        | & patt < sort guard
        | | patt < sort guard

`declaration =
    | let patt bind sort
    | const patt bind sort
    | inf patt bind sort
    `bind =
        | <
        | <>

`patt =
	| _
    | _ident | _0ident | ... | _n째ident         // declare a variable of name `_n째ident` and type `ident`
	| const
	| `word
	| patt:type

	| patt::patt
	| (patt % patt)
	| (patt.patt)                             // (parameter.inductive_data)

general type rules:
	(sort) - "a term has a type, a type has a kind, kinds and types are both in sort => x : * : # : U1 : U2 ..."
		0 ]- * : # : U1 : U2 : U3 : ...

	(var) - "Given a context if A is a sort then x:A is well typed"
		T ]- A:s
		T , x:A ]- x:A

	(weak) - "Given a context, adding to it will not remove derivation possible from it"
		T ]- A:B				T ]- C:s
		T , x:C ]- A:B
		if x isn't contained in T

	(conv) - "If given a context with A:B and B':s then you can derive A:B' if B is beta reducible to B'"
		T ]- A:B 				T ]- B':s
		T ]- A:B'
		if B is beta reductible to B'

type rules dependent functions(as a negative type):
s is sort, minuscule are patterns, capitalised are any term
T = context , ]- = derives , || = dependent function type , \ = lambda abstraction , T,+:^ ]- 째 = by adding (+) of (^) to the context you can derive (째)
	(form) - "If given a context and adding to it x:A you can derive B:s2, then you can abstract x from B with (||x:A . B):s2"
		T ]- A:s1 				T , x:A ]- B:s2
		T ]- (||x:A . B):s2
		if 'x' isn't free in 'B'      (||x:A . B):s2 = (A . B):s2

	(appl/elim) - "Given a context with M:(||x:A . B) and N:A then (N M) has sort B with every occurrence of x in it replaced with N"
		T , x:A ]- Y:B                  T ]- M:(||x:A . B)	T ]- N:A
		T ]- (N M):B[N/x]

	(abst/intro) - "If given a context and adding x:A to it you can derive M:B and (||x:A . B) is a sort then (\x:A . M) has sort (||x:A . B)"
		T , x:A ]- M:B			T ]- (||x:A . B):s
		T ]- (>x:A; M):(||x:A . B)


type rules dependent pair(as a negative type):
	(form) -  "If given a context and adding to it x:A you can derive B:s2, then you can abstract x from B with (^^x:A % B):s2"
		T ]- A:s1 				T , x:A ]- B:s2
		T ]- (^^x:A % B):s2
		if 'x' isn't free in 'B'      (^^x:A % B):s2 = (A % B):s2

	(partition/elim) - "If given a contex in which M:(^^x:A % B) than the first element has type A, the second has type B with every x replaced with the first elemetn, and M can be evaulated to (A % evaluated type of B) when the first element is known"
		T ]- M:(^^x:A % B)
		T ]- M@0:A  			T ]- M@1:B[M@1/x]

	(intro) - "If given a context and adding x:A to it you can derive M:B and (^^x:A % B) is a sort then (A >`x % M) has type (^^x:A % B)"
		T , x:A	]- Y:B			T ]- (^^x:A % B):s
		T ]- (x >`x % Y):(^^x:A % B)  	T ]- (x % Y):(^^x:A % B)
